# Basic rendering techniques

## Textures

### Concepts

Textures are split in two parts, accessed through descriptor sets:
- The **Image** data itself
- The **Sampler** : an object that accesses the image using pre-defined methods, such as picking a point between texels or beyond the edge of the image.

You can have separate descriptor sets, but there is a **Combined Image Sampler** to get both at the same time.

To load image data, we will use stb_image, then copy data to a buffer, with the usual process:
- Create a Buffer and Memory
- Use `memcpy` to map image data to memory
- Use Staging Buffers because the texture data won't be changing and can be stored on GPU without host access.

We will create our image with the layout `vk::ImageLayout::eUndefined`. Then when transfering the Image from Staging Buffer to a destination, the image will need to be in layout `vk::ImageLayout::eTransferDstOptimal`. After this transfer, in order to be used, it will switch layout to `vk::ImageLayout::eShaderReadOnlyOptimal`. Usually we transitions automatically attachments in the render pass through subpass dependencies. But images are not attachments, so we will have to transition layouts manually. To do this we will use **Pipeline Barriers**.

Pipeline barriers are similar to semaphores because it is used to synchronise CPU actions, with the difference we can set thems wherever we want. They are barriers in the pipeline to organise events and ensure no overlaps. Pipeline barriers will separate queues of command between those which are before the barrier and those which are after. They are useful in our cases because they can force layout transitions when crossing the barrier.

We will use a specific barrier called **Image Memory Barrier**. They restricts order of access to image resource and allow image layout transitions. They will state two points in time:
- A time a transition can only occur after;
- A time a transition must occur before.

Once the data in a buffer, we must define the sampler. Options are similar as in OpenGL : filtering, addressing, anisotropy. Anisotropy will require a feature to be enabled on the Device.

The descriptor sets creation will be similar to the previous ones. This time however the descriptor set layout will differ and the stage it will connect will be the fragment shader's. The descriptor pool size will be of Compined Image Sampler type. The descriptor write will use `pImageInfo` as opposed to `pBufferInfo`.

To use the descriptor set, we will do same way we did before. We will just ensure that vertex data is updated to hold texel values. And of course we will update the shaders.

We will setup the code to use multiple textures at the same time.

### Loading a texture file

#### File loading

We will use `stb_image` to load files. Include the `stb_image.h` file to laod images : go to https://github.com/nothings/stb/blob/master/stb_image.h , get to the raw file, download and include it in your project. Also create a `textures` folder into your project folder.

`VulkanRenderer.h`
```
...
#include "stb_image.h"
...
```

`Main.cpp`
```
#define STB_IMAGE_IMPLEMENTATION
```

Use stb_image to create a public load image function:
```
stbi_uc* VulkanRenderer::loadTextureFile(const string& filename, int* width, int* height, vk::DeviceSize* imageSize)
{
	// Number of channel image uses
	int channels;

	// Load pixel data for image
	string path = "textures/" + filename;
	stbi_uc* image = stbi_load(path.c_str(), width, height, &channels, STBI_rgb_alpha);

	if (!image)
	{
		throw std::runtime_error("Failed to load texture file: " + path);
	}

	*imageSize = *width * *height * 4;	// RGBA has 4 channels
	return image;
}
```

#### Loading image texture on staging buffer

We first need to create vectors that will hold multiple textures and their memory.

`VulkanRenderer.h`
```
	vector<VkImage> textureImages;
	vector<vk::ImageView> textureImageViews;
	vector<VkDeviceMemory> textureImageMemory;
```

A function will ensure the texture load and put the data in the staging buffer.

`VulkanRenderer.cpp`
```
int VulkanRenderer::createTextureImage(const string& filename)
{
	// Load image file
	int width, height;
	vk::DeviceSize imageSize;
	stbi_uc* imageData = loadTextureFile(filename, &width, &height, &imageSize);

	// Create staging buffer to hold loaded data, ready to copy to device
	vk::Buffer imageStagingBuffer;
	vk::DeviceMemory imageStagingBufferMemory;
	createBuffer(mainDevice.physicalDevice, mainDevice.logicalDevice,
		imageSize, vk::BufferUsageFlagBits::eTransferSrc,
		vk::MemoryPropertyFlagBits::eHostVisible | vk::MemoryPropertyFlagBits::eHostCoherent,
		&imageStagingBuffer, &imageStagingBufferMemory);

	// Copy image data to the staging buffer
	void* data;
	mainDevice.logicalDevice.mapMemory(imageStagingBufferMemory, {}, imageSize, {}, &data);
	memcpy(data, imageData, static_cast<size_t>(imageSize));
	mainDevice.logicalDevice.unmapMemory(imageStagingBufferMemory);

	// Free original image data
	stbi_image_free(imageData);
    ...
}
```

This is only the beginning of this function. We now have to copy the staging buffer to an image. We already have a function to copy a buffer to an other buffer. We will modify this function so that it can copy a buffer to an image.

#### Copy buffer to the image

We start with a little refactoring:

`VulkanUtilities.h`
```
static vk::CommandBuffer beginCommandBuffer(vk::Device device, vk::CommandPool commandPool)
{
	// Command buffer to hold transfer commands
	vk::CommandBuffer commandBuffer;

	// Command buffer details
	vk::CommandBufferAllocateInfo allocInfo{};
	allocInfo.level = vk::CommandBufferLevel::ePrimary;
	allocInfo.commandPool = commandPool;
	allocInfo.commandBufferCount = 1;

	// Allocate command buffer from pool
	commandBuffer = device.allocateCommandBuffers(allocInfo).front();

	// Information to begin command buffer record
	vk::CommandBufferBeginInfo beginInfo{};
	// Only using command buffer once, then become unvalid
	beginInfo.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;

	// Begin records transfer commands
	commandBuffer.begin(beginInfo);
	return commandBuffer;
}

static void endAndSubmitCommandBuffer(vk::Device device, vk::CommandPool commandPool, vk::Queue queue, vk::CommandBuffer commandBuffer)
{
	// End record commands
	commandBuffer.end();

	// Queue submission info
	vk::SubmitInfo submitInfo{};
	submitInfo.commandBufferCount = 1;
	submitInfo.pCommandBuffers = &commandBuffer;

	// Submit transfer commands to transfer queue and wait until it finishes
	queue.submit(1, &submitInfo, nullptr);
	queue.waitIdle();

	// Free temporary command buffer
	device.freeCommandBuffers(commandPool, 1, &commandBuffer);
}

static void copyBuffer(vk::Device device, vk::Queue transferQueue, vk::CommandPool transferCommandPool,
	vk::Buffer srcBuffer, vk::Buffer dstBuffer, vk::DeviceSize bufferSize)
{
	// Command buffer to hold transfer commands
	vk::CommandBuffer transferCommandBuffer = beginCommandBuffer(device, transferCommandPool);

	// Region of data to copy from and to
	vk::BufferCopy bufferCopyRegion{};
	bufferCopyRegion.srcOffset = 0;		// From the start of first buffer...
	bufferCopyRegion.dstOffset = 0;		// ...copy to the start of second buffer
	bufferCopyRegion.size = bufferSize;

	// Copy src buffer to dst buffer
	transferCommandBuffer.copyBuffer(srcBuffer, dstBuffer, bufferCopyRegion);

	// Submit and free
	endAndSubmitCommandBuffer(device, transferCommandPool, transferQueue, transferCommandBuffer);
}
```

Now we can create a function to copy from the buffer to the image:

```
static void copyImageBuffer(vk::Device device, vk::Queue transferQueue,
	vk::CommandPool transferCommandPool, vk::Buffer srcBuffer, vk::Image dstImage,
	uint32_t width, uint32_t height)
{
	// Create buffer
	vk::CommandBuffer transferCommandBuffer =
		beginCommandBuffer(device, transferCommandPool);

	vk::BufferImageCopy imageRegion{};
	// All data of image is tightly packed
	// -- Offset into data
	imageRegion.bufferOffset = 0;
	// -- Row length of data to calculate data spacing
	imageRegion.bufferRowLength = 0;
	// -- Image height of data to calculate data spacing
	imageRegion.bufferImageHeight = 0;

	// Which aspect to copy (here: colors)
	imageRegion.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
	// Mipmap level to copy
	imageRegion.imageSubresource.mipLevel = 0;
	// Starting array layer if array
	imageRegion.imageSubresource.baseArrayLayer = 0;
	// Number of layers to copy starting at baseArray
	imageRegion.imageSubresource.layerCount = 1;
	// Offset into image (as opposed to raw data into bufferOffset)
	imageRegion.imageOffset = vk::Offset3D { 0, 0, 0 };
	// Size of region to copy (xyz values)
	imageRegion.imageExtent = vk::Extent3D { width, height, 1 };

	// Copy buffer to image
	transferCommandBuffer.copyBufferToImage(srcBuffer,
		dstImage, vk::ImageLayout::eTransferDstOptimal, 1, &imageRegion);

	endAndSubmitCommandBuffer(device, transferCommandPool,
		transferQueue, transferCommandBuffer);
}
```

We can now finish our `createTextureImage` function:

`VulkanRenderer.cpp`
```
int VulkanRenderer::createTextureImage(const string& filename)
{
	// Load image file
	int width, height;
	vk::DeviceSize imageSize;
	stbi_uc* imageData = loadTextureFile(filename, &width, &height, &imageSize);

	// Create staging buffer to hold loaded data, ready to copy to device
	vk::Buffer imageStagingBuffer;
	vk::DeviceMemory imageStagingBufferMemory;
	createBuffer(mainDevice.physicalDevice, mainDevice.logicalDevice,
		imageSize, vk::BufferUsageFlagBits::eTransferSrc,
		vk::MemoryPropertyFlagBits::eHostVisible | vk::MemoryPropertyFlagBits::eHostCoherent,
		&imageStagingBuffer, &imageStagingBufferMemory);

	// Copy image data to the staging buffer
	void* data;
	mainDevice.logicalDevice.mapMemory(imageStagingBufferMemory, {}, imageSize, {}, &data);
	memcpy(data, imageData, static_cast<size_t>(imageSize));
	mainDevice.logicalDevice.unmapMemory(imageStagingBufferMemory);

	// Free original image data
	stbi_image_free(imageData);

	// Create image to hold final texture
	vk::Image texImage;
	vk::DeviceMemory texImageMemory;
	texImage = createImage(width, height, vk::Format::eR8G8B8A8Unorm, vk::ImageTiling::eOptimal,
		vk::ImageUsageFlagBits::eTransferDst | vk::ImageUsageFlagBits::eSampled,
		vk::MemoryPropertyFlagBits::eDeviceLocal, &texImageMemory);

	// -- COPY DATA TO IMAGE --
	// Copy image data
	copyImageBuffer(mainDevice.logicalDevice, graphicsQueue,
		graphicsCommandPool, imageStagingBuffer, texImage, width, height);

	// Add texture data to vector for reference
	textureImages.push_back(texImage);
	textureImageMemory.push_back(texImageMemory);

	// Destroy stagin buffers
	mainDevice.logicalDevice.destroyBuffer(imageStagingBuffer, nullptr);
	mainDevice.logicalDevice.freeMemory(imageStagingBufferMemory, nullptr);

	// Return index of new texture image
	return textureImages.size() - 1;
}
```

Wew

#### Clean up and use of the texture

Let's not forget to destroy the texture images and memory:

```
void VulkanRenderer::clean()
{
	mainDevice.logicalDevice.waitIdle();

	for (auto i = 0; i < textureImages.size(); ++i)
	{
		mainDevice.logicalDevice.destroyImage(textureImages[i], nullptr);
		mainDevice.logicalDevice.freeMemory(textureImageMemory[i], nullptr);
	}
  ...
}
```

And now test a texture load:

```
void VulkanRenderer::init()
{
    ...
    // Pipeline
    ...
    createGraphicsCommandPool();

    // Texture
    int catTexture = createTextureImage("cat.jpg");

    // Objects
    ...
}
```

The code launches but there is a validation error:
```
Submitted command buffer expects VkNonDispatchableHandle [...] to be in layout VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
 -- instead, current layout is VK_IMAGE_LAYOUT_UNDEFINED.
```

We will have to take the image and transition it to the 		vk::ImageLayout::eTransferDstOptimal format.

### Transitionning the layout

We will use a pipeline barrier to make this transition happen. First we will create a function to handle transition with a barrier:

`VulkanUtilities.h`
```
static void transitionImageLayout(vk::Device device, vk::Queue queue, vk::CommandPool commandPool,
	vk::Image image, vk::ImageLayout oldLayout, vk::ImageLayout newLayout)
{
	vk::CommandBuffer commandBuffer = beginCommandBuffer(device, commandPool);

	vk::ImageMemoryBarrier imageMemoryBarrier{};
	imageMemoryBarrier.oldLayout = oldLayout;
	imageMemoryBarrier.newLayout = newLayout;
	// Queue family to transition from
	imageMemoryBarrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	// Queue family to transition to
	imageMemoryBarrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;
	// Image being accessed and modified as part fo barrier
	imageMemoryBarrier.image = image;
	imageMemoryBarrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
	// First mip level to start alterations on
	imageMemoryBarrier.subresourceRange.baseMipLevel = 0;
	// Number of mip levels to alter starting from baseMipLevel
	imageMemoryBarrier.subresourceRange.levelCount = 1;
	// First layer to starts alterations on
	imageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
	// Number of layers to alter starting from baseArrayLayer
	imageMemoryBarrier.subresourceRange.layerCount = 1;

	vk::PipelineStageFlags srcStage;
	vk::PipelineStageFlags dstStage;

	// If transitioning from new image to image ready to receive data
	if (oldLayout == vk::ImageLayout::eUndefined &&
		newLayout == vk::ImageLayout::eTransferDstOptimal)
	{
		// Memory access stage transition must happen after this stage
		imageMemoryBarrier.srcAccessMask = vk::AccessFlagBits::eNone;
		// Memory access stage transition must happen before this stage
		imageMemoryBarrier.dstAccessMask = vk::AccessFlagBits::eTransferWrite;

		// Transfer from old layout to new layout has to occur after any
		// point of the top of the pipeline and before it attemps to to a
		// transfer write at the transfer stage of the pipeline
		srcStage = vk::PipelineStageFlagBits::eTopOfPipe;
		dstStage = vk::PipelineStageFlagBits::eTransfer;
	}

	commandBuffer.pipelineBarrier(
		srcStage, dstStage,		// Pipeline stages (match to src and dst AccessMasks)
		{},						// Dependency flags
		0, nullptr,				// Memory barrier count and data
		0, nullptr,				// Buffer memory barrier count and data
		1, &imageMemoryBarrier	// Image memory barrier count and data
	);

	endAndSubmitCommandBuffer(device, commandPool, queue, commandBuffer);
}
```

We can now use this function juste before copying the texture data:

`VulkanRenderer.cpp`
```
int VulkanRenderer::createTextureImage(string filename)
{
    ...
	// -- COPY DATA TO IMAGE --
	// Transition image to be DST for copy operations
	transitionImageLayout(mainDevice.logicalDevice, graphicsQueue, graphicsCommandPool,
		texImage, vk::ImageLayout::eUndefined, vk::ImageLayout::eTransferDstOptimal);

	// Copy image data
	copyImageBuffer(mainDevice.logicalDevice, graphicsQueue,
		graphicsCommandPool, imageStagingBuffer, texImage, width, height);
    ...
}
```

Now it should work without an error.

Nevertheless, our image format is now optimal for a destination of a transfer. But we want it to be in a format optimal for a shader to use it.

### Prepare shader use

Update `transitionImageLayout`:

`VulkanUtilities.h`
```
    ...
	// If transitioning from new image to image ready to receive data
	if (oldLayout == vk::ImageLayout::eUndefined &&
		newLayout == vk::ImageLayout::eTransferDstOptimal)
	{
		// Memory access stage transition must happen after this stage
		imageMemoryBarrier.srcAccessMask = vk::AccessFlagBits::eNone;
		// Memory access stage transition must happen before this stage
		imageMemoryBarrier.dstAccessMask = vk::AccessFlagBits::eTransferWrite;

		// Transfer from old layout to new layout has to occur after any
		// point of the top of the pipeline and before it attemps to to a
		// transfer write at the transfer stage of the pipeline
		srcStage = vk::PipelineStageFlagBits::eTopOfPipe;
		dstStage = vk::PipelineStageFlagBits::eTransfer;
	}
	else if (oldLayout == vk::ImageLayout::eTransferDstOptimal &&
		newLayout == vk::ImageLayout::eShaderReadOnlyOptimal)
	{
		// Transfer is finished
		imageMemoryBarrier.srcAccessMask = vk::AccessFlagBits::eTransferWrite;
		// Before the shader reads
		imageMemoryBarrier.dstAccessMask = vk::AccessFlagBits::eShaderRead;

		srcStage = vk::PipelineStageFlagBits::eTransfer;
		dstStage = vk::PipelineStageFlagBits::eFragmentShader;
	}
    ...
```

We put the transition to action. Update VulkanRenderer::createTextureImage:
```
    ...
	// -- COPY DATA TO IMAGE --
	// Transition image to be DST for copy operations
	transitionImageLayout(mainDevice.logicalDevice, graphicsQueue, graphicsCommandPool,
		texImage, vk::ImageLayout::eUndefined, vk::ImageLayout::eTransferDstOptimal);

	// Copy image data
	copyImageBuffer(mainDevice.logicalDevice, graphicsQueue,
		graphicsCommandPool, imageStagingBuffer, texImage, width, height);

	// -- READY FOR SHADER USE --
	transitionImageLayout(mainDevice.logicalDevice, graphicsQueue, graphicsCommandPool,
		texImage, vk::ImageLayout::eTransferDstOptimal, vk::ImageLayout::eShaderReadOnlyOptimal);

	// Add texture data to vector for reference
    ...
```

### Create textures

Now we will use the images to create ImageViews, in order to be able to display them. Declare a new `createTexture` function.

```
int VulkanRenderer::createTexture(const string& filename)
{
	int textureImageLocation = createTextureImage(filename);

	vk::ImageView imageView = createImageView(textureImages[textureImageLocation],
		vk::Format::eR8G8B8A8Unorm, vk::ImageAspectFlagBits::eColor);
	textureImageViews.push_back(imageView);

	// TODO : Create Descriptor sets

	return 0;
}
```

In `init`, replace the function:
```
void VulkanRenderer::init()
{
    ...
    // Pipeline
    ...
    createGraphicsCommandPool();

    // Texture
		int catTexture = createTexture("cat.jpg");

    // Objects
    ...
}
```


Because we create an image view we have to clean it:

```
void VulkanRenderer::clean()
{
	mainDevice.logicalDevice.waitIdle();

	for (auto i = 0; i < textureImages.size(); ++i)
	{
		mainDevice.logicalDevice.destroyImageView(textureImageViews[i], nullptr);
		...
	}
  ...
```

### Create a texture sampler

`VulkanRenderer.h`
```
	vk::Sampler textureSampler;
	void createTextureSampler();
```

Use it in `init`:

`VulkanRenderer.cpp`
```
...
    // Commands
    createGraphicsCommandBuffers();
    createTextureSampler();
    createSynchronisation();
...
```

```
void VulkanRenderer::createTextureSampler()
{
	vk::SamplerCreateInfo samplerCreateInfo{};
	// How to render when image is magnified on screen
	samplerCreateInfo.magFilter = vk::Filter::eLinear;
	// How to render when image is minified on screen
	samplerCreateInfo.minFilter = vk::Filter::eLinear;
	// Texture wrap in the U direction
	samplerCreateInfo.addressModeU = vk::SamplerAddressMode::eRepeat;
	// Texture wrap in the V direction
	samplerCreateInfo.addressModeV = vk::SamplerAddressMode::eRepeat;
	// Texture wrap in the W direction
	samplerCreateInfo.addressModeW = vk::SamplerAddressMode::eRepeat;
	// When no repeat, texture become black beyond border
	samplerCreateInfo.borderColor = vk::BorderColor::eIntOpaqueBlack;
	// Coordinates ARE normalized. When true, coords are between 0 and image size
	samplerCreateInfo.unnormalizedCoordinates = false;
	// Fade between two mipmaps is linear
	samplerCreateInfo.mipmapMode = vk::SamplerMipmapMode::eLinear;
	// Add a bias to the mimmap level
	samplerCreateInfo.mipLodBias = 0.0f;
	samplerCreateInfo.minLod = 0.0f;
	samplerCreateInfo.maxLod = 0.0f;
	// Overcome blur when a texture is stretched because of perspective with angle
	samplerCreateInfo.anisotropyEnable = true;
	// Anisotropy number of samples
	samplerCreateInfo.maxAnisotropy = 16;

	textureSampler = mainDevice.logicalDevice.createSampler(samplerCreateInfo);
}
```

Don't forget to clean:
```
void VulkanRenderer::clean()
{
	mainDevice.logicalDevice.waitIdle();

	mainDevice.logicalDevice.destroySampler(textureSampler);
  ...
```

If we run the code now, there is an error: we have not enable anisotropic sampling. We have to enable this feature in `createLogicalDevice`:

```
void VulkanRenderer::createLogicalDevice()
{
	...
	// Features
	vk::PhysicalDeviceFeatures deviceFeatures {};
	deviceFeatures.samplerAnisotropy = true;
	deviceCreateInfo.pEnabledFeatures = &deviceFeatures;
    ...
```

We have to check the graphics card supports this feature in `checkDeviceSuitable`:
```
bool VulkanRenderer::checkDeviceSuitable(vk::PhysicalDevice device)
{
	...
	return indices.isValid() && extensionSupported && swapchainValid
		&& deviceFeatures.samplerAnisotropy;
}
```

Now we will setup the descriptor sets

### Sampler descriptor sets

#### Pool

We need a descriptor pool for the sampler:

`VulkanRenderer.h`
```
	vk::DescriptorPool samplerDescriptorPool;
```

We start by creating descriptor pools at the end of `createDescriptorPool`:

```
void VulkanRenderer::createDescriptorPool()
{
	...
	// -- SAMPLER DESCRIPTOR POOL --
	// Texture sampler pool
	vk::DescriptorPoolSize samplerPoolSize{};
	// We assume one texture byobject.
	samplerPoolSize.descriptorCount = MAX_OBJECTS;

	vk::DescriptorPoolCreateInfo samplerPoolCreateInfo{};
	// The maximum for this is actually very high
	samplerPoolCreateInfo.maxSets = MAX_OBJECTS;
	samplerPoolCreateInfo.poolSizeCount = 1;
	samplerPoolCreateInfo.pPoolSizes = &samplerPoolSize;

	samplerDescriptorPool = mainDevice.logicalDevice.createDescriptorPool(samplerPoolCreateInfo);
}
```

#### Layout

We currently have two descriptor sets inputs. We now create a descriptor set layout for the sampler.

`VulkanRenderer.h`
```
	vk::DescriptorSetLayout samplerDescriptorSetLayout;
```

```
void VulkanRenderer::createDescriptorSetLayout()
{
	// -- UNIFORM VALUES DESCRIPTOR SETS LAYOUT --
	...
	// -- SAMPLER DESCRIPTOR SETS LAYOUT --
	vk::DescriptorSetLayoutBinding samplerLayoutBinding;
	// Binding 0 for descriptor set 1
	samplerLayoutBinding.binding = 0;
	samplerLayoutBinding.descriptorType = vk::DescriptorType::eCombinedImageSampler;
	samplerLayoutBinding.descriptorCount = 1;
	samplerLayoutBinding.stageFlags = vk::ShaderStageFlagBits::eFragment;
	samplerLayoutBinding.pImmutableSamplers = nullptr;

	vector<vk::DescriptorSetLayoutBinding> samplerLayoutBindings{ samplerLayoutBinding };

	vk::DescriptorSetLayoutCreateInfo textureLayoutCreateInfo{};
	textureLayoutCreateInfo.bindingCount =
		static_cast<uint32_t>(samplerLayoutBindings.size());
	textureLayoutCreateInfo.pBindings = samplerLayoutBindings.data();

	samplerDescriptorSetLayout = mainDevice.logicalDevice.createDescriptorSetLayout(textureLayoutCreateInfo);
}
```

In `createGraphicsPipeline`, go to the pipeline lyout part and update it to add the new descriptor set:

```
void VulkanRenderer::createGraphicsPipeline()
{
    ...
	// -- PIPELINE LAYOUT --
	array<vk::DescriptorSetLayout, 2> descriptorSetLayouts{
		descriptorSetLayout, samplerDescriptorSetLayout
	};

	vk::PipelineLayoutCreateInfo pipelineLayoutCreateInfo{};
	pipelineLayoutCreateInfo.setLayoutCount = static_cast<uint32_t>(descriptorSetLayouts.size());
	pipelineLayoutCreateInfo.pSetLayouts = descriptorSetLayouts.data();
	pipelineLayoutCreateInfo.pushConstantRangeCount = 1;
	pipelineLayoutCreateInfo.pPushConstantRanges = &pushConstantRange;

	// Create pipeline layout
	pipelineLayout = mainDevice.logicalDevice.createPipelineLayout(pipelineLayoutCreateInfo);
    ...
}
```

#### Descriptor sets

`VulkanRenderer.h`
```
	vector<vk::DescriptorSet> samplerDescriptorSets;
	int createTextureDescriptor(vk::ImageView textureImageView);
```

Previously we had one descriptor set per swapchain images, because the values would change for each image. But here, we will have one for each texture, that won't change.
```
int VulkanRenderer::createTextureDescriptor(VkImageView textureImageView)
{
	vk::DescriptorSet descriptorSet;

	vk::DescriptorSetAllocateInfo setAllocInfo{};
	setAllocInfo.descriptorPool = samplerDescriptorPool;
	setAllocInfo.descriptorSetCount = 1;
	setAllocInfo.pSetLayouts = &samplerDescriptorSetLayout;

	vk::Result result = mainDevice.logicalDevice.allocateDescriptorSets(&setAllocInfo, &descriptorSet);
	if (result != vk::Result::eSuccess)
	{
		throw std::runtime_error("Failed to allocate texture descriptor set.");
	}

	// Texture image info
	vk::DescriptorImageInfo imageInfo{};
	// Image layout when in use
	imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
	// Image view to bind to set
	imageInfo.imageView = textureImageView;
	// Sampler to use for set
	imageInfo.sampler = textureSampler;

	// Write info
	vk::WriteDescriptorSet descriptorWrite{};
	descriptorWrite.dstSet = descriptorSet;
	descriptorWrite.dstBinding = 0;
	descriptorWrite.dstArrayElement = 0;
	descriptorWrite.descriptorType = vk::DescriptorType::eCombinedImageSampler;
	descriptorWrite.descriptorCount = 1;
	descriptorWrite.pImageInfo = &imageInfo;

	// Update new descriptor set
	mainDevice.logicalDevice.updateDescriptorSets(1, &descriptorWrite, 0, nullptr);

	// Add descriptor set to list
	samplerDescriptorSets.push_back(descriptorSet);

	return samplerDescriptorSets.size() - 1;
}
```

We can now use this function in `createTexture`:
```
int VulkanRenderer::createTexture(const string& filename)
{
	int textureImageLocation = createTextureImage(filename);

	vk::ImageView imageView = createImageView(textureImages[textureImageLocation],
		vk::Format::eR8G8B8A8Unorm, vk::ImageAspectFlagBits::eColor);
	textureImageViews.push_back(imageView);

	int descriptorLoc = createTextureDescriptor(imageView);

	// Return location of set with texture
	return descriptorLoc;
}
```

#### Clean and init

Don't forget to clean:
```
void VulkanRenderer::clean()
{
	mainDevice.logicalDevice.waitIdle();

	mainDevice.logicalDevice.destroyDescriptorPool(samplerDescriptorPool, nullptr);
	mainDevice.logicalDevice.destroyDescriptorSetLayout(samplerDescriptorSetLayout, nullptr);
    ...
}
```

Also move all the code of objects and texture creation at the end of `init` to avoid errors.


### Connect mesh and texture

#### Texture id
We create a texture id for the mesh:

`VulkanMesh.h`
```
public:
	VulkanMesh(vk::PhysicalDevice physicalDeviceP, vk::Device deviceP,
		vk::Queue transferQueue, vk::CommandPool transferCommandPool,
		vector<Vertex>* vertices, vector<uint32_t>* indices, int texIdP);
	...
	int getTexId() const { return texId; }
private:
	...
	int texId;
```

We use this new function in `init`. We will create two texture with the same file instead of one, but this is for example sake, so that our code supports multiple textures.

`VulkanRenderer.cpp`
```
		VulkanMesh firstMesh = VulkanMesh(mainDevice.physicalDevice,
			mainDevice.logicalDevice, graphicsQueue, graphicsCommandPool,
			&meshVertices1, &meshIndices, createTexture("cat.jpg"));

		VulkanMesh secondMesh = VulkanMesh(mainDevice.physicalDevice,
			mainDevice.logicalDevice, graphicsQueue, graphicsCommandPool,
			&meshVertices2, &meshIndices, createTexture("cat.jpg"));
```

#### Record commands

We can update the bind descriptor sets command:

```
void VulkanRenderer::recordCommands(uint32_t currentImage)
{
	...
	// Draw all meshes
	for (size_t j = 0; j < meshes.size(); ++j)
	{
        ...
		// Bind descriptor sets
		array<vk::DescriptorSet, 2> descriptorSetsGroup {
			descriptorSets[currentImage], samplerDescriptorSets[meshes[j].getTexId()]
		};
		commandBuffers[currentImage].bindDescriptorSets(vk::PipelineBindPoint::eGraphics, pipelineLayout, 0,
			static_cast<uint32_t>(descriptorSetsGroup.size()), descriptorSetsGroup.data(), 0, nullptr);
        ...
    }
    ...
}
```

#### Texture coordinates and shader update

Start with updating the Vertex struct:

`VulkanUtilities.h`
```
struct Vertex
{
	glm::vec3 pos;
	glm::vec3 col;
	glm::vec2 tex;
};
```

Nom in `init` add the required data:
```
    ...
    // -- Vertex data
    vector<Vertex> meshVertices1{
        {{-0.4f,  0.4f, 0.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}},	// 0
        {{-0.4f, -0.4f, 0.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},	// 1
        {{ 0.4f, -0.4f, 0.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},	// 2
        {{ 0.4f,  0.4f, 0.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},	// 3
    };

    vector<Vertex> meshVertices2{
        {{-0.4f,  0.4f, 0.0f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f}},	// 0
        {{-0.4f, -0.4f, 0.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},	// 1
        {{ 0.4f, -0.4f, 0.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f}},	// 2
        {{ 0.4f,  0.4f, 0.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f}},	// 3
    };
    ...
```

We now have to update the attribute descriptions in `createGraphicsPipeline`:

```
	// Create pipeline

	...
	// Different attributes
	array<VkVertexInputAttributeDescription, 3> attributeDescriptions;

	...

	// Texture attributes
	attributeDescriptions[2].binding = 0;
	attributeDescriptions[2].location = 2;
	attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT;
	attributeDescriptions[2].offset = offsetof(Vertex, tex);
```

And finally modify the shaders:

`shader.vert`
```
#version 450

// From vertex input stage
layout(location = 0) in vec3 pos;
layout(location = 1) in vec3 col;
layout(location = 2) in vec2 tex;

// Uniform Buffer Object
layout(set = 0, binding = 0) uniform ViewProjection {
    mat4 projection;
    mat4 view;
} viewProjection;

// Push constant
layout(push_constant) uniform PushModel {
    mat4 model;
} pushModel;

// To fragment shader
layout(location = 0) out vec3 fragColor;
layout(location = 1) out vec2 fragTex;

void main() {
    gl_Position = viewProjection.projection * viewProjection.view *
		pushModel.model * vec4(pos, 1.0);
    fragColor = col;
    fragTex = tex;
}
```

`shader.frag`
```
#version 450

// Input colors from vertex shader
layout(location = 0) in vec3 fragColor;
layout(location = 1) in vec2 fragTex;

layout(set = 1, binding = 0) uniform sampler2D textureSampler;

// Final output color, must have location
layout(location = 0) out vec4 outColor;

void main() {
    outColor = texture(textureSampler, fragTex);
}
```

Also change model matrices in the `main` to easily check your models:
`main.cpp`
```
...
	firstModel = glm::translate(firstModel, glm::vec3(0.0f, -1.0f, -2.0f));
	firstModel = glm::rotate(firstModel, glm::radians(angle), glm::vec3(0.0f, 1.0f, 1.0f));

	secondModel = glm::translate(secondModel, glm::vec3(0.0f, -1.0f, -1.0f));
	secondModel = glm::rotate(secondModel, glm::radians(-angle * 2), glm::vec3(0.0f, 0.0f, 1.0f));
...
```

And now the texture is displayed ! This project is available in the VulkanApp_Basic01_Textures folder.

## 3D models

### Preparation

#### Open asset importer library

To load 3D meshes, we will use Assimp. You can get this 3d model loading library on by folloying instructions at https://github.com/assimp/assimp/blob/master/Build.md . On Windows, the easiest way is to use the vcpkg system.

Once the library in built and  installed, include the files and link the lib. If you installed assimp with vcpkg, you will find the `include` and `lib` folders here : C:\[path-to]\vcpkg\packages\assimp_x86-windows . Do not forget to name the library you are using in Linker/Input.


#### New class type for model representations

Create a `VulkanMeshModel` class.

`VulkanMeshModel.h`
```
#pragma once
#include <glm/glm.hpp>
#include <assimp/scene.h>

#include <vector>
using std::vector;

#include "VulkanMesh.h"

class VulkanMeshModel
{
public:
	VulkanMeshModel();
	VulkanMeshModel(vector<VulkanMesh> meshesP);
	~VulkanMeshModel();

	size_t getMeshCount() const { return meshes.size(); };
	VulkanMesh* getMesh(size_t index);

	glm::mat4 getModel() const { return model; };
	void setModel(glm::mat4 modelP) { model = modelP; }
	void destroyMeshModel();


private:
	vector<VulkanMesh> meshes;
	glm::mat4 model;
};
```

A scene in assimp is a hierarchy of mesh models. We will need to get the texture filenames for each model mesh. Here is the implementation:

`VulkanMeshModel.cpp`
```
#include "VulkanMeshModel.h"

VulkanMeshModel::VulkanMeshModel()
{
}

VulkanMeshModel::VulkanMeshModel(vector<VulkanMesh> meshesP)
	: meshes(meshesP), model(glm::mat4(1.0f))
{
}

VulkanMeshModel::~VulkanMeshModel()
{
}

VulkanMesh* VulkanMeshModel::getMesh(size_t index)
{
	if (index >= meshes.size())
	{
		throw std::runtime_error("Attempted to access a mesh with not attributed index");
	}
	return &meshes[index];
}

void VulkanMeshModel::destroyMeshModel()
{
	for (auto& mesh : meshes)
	{
		mesh.destroyBuffers();
	}
}
```

### Loading a model

Include assimp and some new variables in the renderer:

`VulkanRenderer.h`
```
#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>
#include "VulkanMeshModel.h"
...
vector<VulkanMeshModel> meshModels;
void createMeshModel(const string& filename);
```

#### Loading texture

We will first load the textures of a model. We will ensure to have a one-to-one relatationship between the loaded textures and the vulkan's texture ids.

`VulkanMeshModel.h`
```
static vector<string> loadMaterials(const aiScene* scene);
```

`VulkanMeshModel.cpp`
```
vector<string> VulkanMeshModel::loadMaterials(const aiScene* scene)
{
	// Create one-to-one size list of texture
	vector<string> textures(scene->mNumMaterials);
	// Go through each material and copy its texture file name if it exists
	for (size_t i = 0; i < textures.size(); ++i)
	{
		// Get material
		aiMaterial* material = scene->mMaterials[i];
		// Initialize texture name with empty string
		textures[i] = "";
		// Check for a diffuse texture
		if (material->GetTextureCount(aiTextureType_DIFFUSE))
		{
			// Get the path of the texture file
			aiString path;
			if (material->GetTexture(aiTextureType_DIFFUSE, 0, &path) == AI_SUCCESS)
			{
				// Cut off any absolute directory information already present
				int index = string(path.data).rfind("\\");
				string filename = string(path.data).substr(index + 1);
				textures[i] = filename;
			}
		}
	}
	return textures;
}
```

We can now start implementing `createMeshModel`:

`VulkaRenderer.cpp`
```
void VulkanRenderer::createMeshModel(const string& filename)
{
	// Import model scene
	Assimp::Importer importer;
	// We want the model to be in triangles, to flip vertically texels uvs, and optimize the use of vertices
	const aiScene* scene = importer.ReadFile(filename, aiProcess_Triangulate |
		aiProcess_FlipUVs | aiProcess_JoinIdenticalVertices);
	if (!scene)
	{
		throw std::runtime_error("Failed to load mesh model: " + filename);
	}

	// Load materials with one to one relationship with texture ids
	vector<string> textureNames = VulkanMeshModel::loadMaterials(scene);

	// Conversion to material list ID to descriptor array ids (we don't keep empty files)
	vector<int> matToTex(textureNames.size());
	// Loop over texture names and create textures for them
	for (size_t i = 0; i < textureNames.size(); ++i)
	{
		if (textureNames[i].empty())
		{
			// Texture 0 will be reserved for a default texture
			matToTex[i] = 0;
		}
		else
		{
			// Return the texture's id
			matToTex[i] = createTexture(textureNames[i]);
		}
	}
	...
}
```

The function is not finished. We will now load the meshs of the model.

#### Loading meshes

Meshes are represented under the shape of a node tree. We will have to go through this tree to retrieve the hierarchy of meshes, represented as nodes.

`VulkanMeshModel.h`
```
	static VulkanMesh loadMesh(vk::PhysicalDevice physicalDeviceP,
		vk::Device deviceP, vk::Queue transferQueue,
		vk::CommandPool transferCommandPool,
		aiMesh* mesh, const aiScene* scene, vector<int> matToTex);

	static vector<VulkanMesh> loadNode(vk::PhysicalDevice physicalDeviceP,
		vk::Device deviceP, vk::Queue transferQueue,
		vk::CommandPool transferCommandPool,
		aiNode* node, const aiScene* scene, vector<int> matToTex);
```

We will first load the mesh by getting all vertices and indices, then use this function to load the node, ie the mesh plus its children in node hierarchy.

`VulkanMeshModel.cpp`
```
VulkanMesh VulkanMeshModel::loadMesh(vk::PhysicalDevice physicalDeviceP,
	vk::Device deviceP, vk::Queue transferQueue,
	vk::CommandPool transferCommandPool, aiMesh* mesh,
	const aiScene* scene, vector<int> matToTex)
{
	vector<Vertex> vertices(mesh->mNumVertices);
	vector<uint32_t> indices;

	// Copy all vertices
	for (size_t i = 0; i < mesh->mNumVertices; ++i)
	{
		// Position
		vertices[i].pos = {
			mesh->mVertices[i].x, mesh->mVertices[i].y, mesh->mVertices[i].z
		};
		// Tex coords if they exists
		if (mesh->mTextureCoords[0])
		{
			vertices[i].tex = {
				mesh->mTextureCoords[0][i].x, mesh->mTextureCoords[0][i].y
			};
		}
		else
		{
			vertices[i].tex = { 0.0f, 0.0f };

		}
		// Vertex color (white)
		vertices[i].col = { 1.0f, 1.0f, 1.0f };
	}

	// Copy all indices, stored by face (triangle)
	for (size_t i = 0; i < mesh->mNumFaces; ++i)
	{
		aiFace face = mesh->mFaces[i];
		for (size_t j = 0; j < face.mNumIndices; ++j)
		{
			indices.push_back(face.mIndices[j]);
		}
	}

	// Create new mesh
	VulkanMesh newMesh = VulkanMesh(physicalDeviceP, deviceP, transferQueue,
		transferCommandPool, &vertices, &indices, matToTex[mesh->mMaterialIndex]);
	return newMesh;
}

vector<VulkanMesh> VulkanMeshModel::loadNode(vk::PhysicalDevice physicalDeviceP,
	vk::Device deviceP, vk::Queue transferQueue,
	vk::CommandPool transferCommandPool, aiNode* node,
	const aiScene* scene, vector<int> matToTex)
{
	vector<VulkanMesh> meshes;
	// Go through each mesh at this node and create it, then add it to our meshList
	for (size_t i = 0; i < node->mNumMeshes; ++i)
	{
		// Load mesh
		meshes.push_back(loadMesh(physicalDeviceP, deviceP, transferQueue,
			transferCommandPool, scene->mMeshes[node->mMeshes[i]], scene, matToTex));
		// Explanation of scene->mMeshes[node->mMeshes[i]]:
		// The scene actually hold the data for the meshes, and the nodes store ids of
		// meshes, that relate to the scene meshes.
	}

	// Go through each node attached to this node and load it,
	// then append their meshes to this node's meshes
	for (size_t i = 0; i < node->mNumChildren; ++i)
	{
		vector<VulkanMesh> newMeshes = loadNode(physicalDeviceP, deviceP, transferQueue,
			transferCommandPool, node->mChildren[i], scene, matToTex);
		meshes.insert(end(meshes), begin(newMeshes), end(newMeshes));
	}

	return meshes;
}
```

We can now get back and complete `createMeshModel`:

`VulkanRenderer.cpp`
```
void VulkanRenderer::createMeshModel(string filename)
{
	// Import model scene
	Assimp::Importer importer;
	// We want the model to be in triangles, to flip vertically texels uvs,
	// and optimize the use of vertices
	const aiScene* scene = importer.ReadFile(filename, aiProcess_Triangulate |
		aiProcess_FlipUVs | aiProcess_JoinIdenticalVertices);
	if (!scene)
	{
		throw std::runtime_error("Failed to load mesh model: " + filename);
	}

	// Load materials with one to one relationship with texture ids
	vector<string> textureNames = VulkanMeshModel::loadMaterials(scene);

	// Conversion to material list ID to descriptor array ids (we don't keep empty files)
	vector<int> matToTex(textureNames.size());
	// Loop over texture names and create textures for them
	for (size_t i = 0; i < textureNames.size(); ++i)
	{
		if (textureNames[i].empty())
		{
			// Texture 0 will be reserved for a default texture
			matToTex[i] = 0;
		}
		else
		{
			// Return the texture's id
			matToTex[i] = createTexture(textureNames[i]);
		}
	}

	// Load in all our meshes
	vector<VulkanMesh> modelMeshes =
		VulkanMeshModel::loadNode(mainDevice.physicalDevice, mainDevice.logicalDevice,
		graphicsQueue, graphicsCommandPool, scene->mRootNode, scene, matToTex);

	auto meshModel = VulkanMeshModel(modelMeshes);
	meshModels.push_back(meshModel);
}
```

#### Cleanup

`VulkanRenderer.cpp`
```
void VulkanRenderer::clean()
{
	mainDevice.logicalDevice.waitIdle();

	for (auto& model : meshModels)
	{
		model.destroyMeshModel();
	}
	...
```

### Display the 3d model

#### Get and load a model

Download a 3d .obj model on free3d.com. You must keep the `.obj` file, the `.mtl` (material) file and the textures folder. Put the obj and material files into a `models` folder inside your VulkanApp project, and the textures into the `textures` folder.

At the end of `init`, you can add:

```
createMeshModel("models/Futuristic combat jet.obj");	// Name of your object
```

You will get an error:
```
ERROR: Failed to allocate texture descriptor set.
```

The error will come from the fact we don't have enough descriptor sets for our new object. Push the max number of objects to 20:
```
const int MAX_OBJECTS = 20;
```

(In function of your model, this number may need to be higher.)

You scene should now load.

#### Draw our models

Let's modify the commands in `recordCommands`. The goal is now to push one constant for a mesh model, giving the model matrix, then go through all children meshes to draw them.

```
void VulkanRenderer::recordCommands(uint32_t currentImage)
{
	...
	// Draw all meshes
	for (size_t j = 0; j < meshModels.size(); ++j)
	{
		// Push constants to given shader stage
		VulkanMeshModel model = meshModels[j];
		glm::mat4 modelMatrix = model.getModel();
		vkCmdPushConstants(commandBuffers[currentImage], pipelineLayout,
			VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(Model), &modelMatrix);
		// We have one model matric for each object, then several children meshes

		for(size_t k = 0; k < model.getMeshCount(); ++k)
		{
			// Bind vertex buffer
			VkBuffer vertexBuffers[] = { model.getMesh(k)->getVertexBuffer() };
			VkDeviceSize offsets[] = { 0 };
			vkCmdBindVertexBuffers(commandBuffers[currentImage],
				0, 1, vertexBuffers, offsets);

			// Bind index buffer
			vkCmdBindIndexBuffer(commandBuffers[currentImage],
				model.getMesh(k)->getIndexBuffer(), 0, VK_INDEX_TYPE_UINT32);

			// Dynamic offet amount
			uint32_t dynamicOffset = static_cast<uint32_t>(modelUniformAlignement) * j;

			// Bind descriptor sets
			array<VkDescriptorSet, 2> descriptorSetsGroup{
				descriptorSets[currentImage],
				samplerDescriptorSets[model.getMesh(k)->getTexId()]
			};
			vkCmdBindDescriptorSets(commandBuffers[currentImage],
				VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0,
				static_cast<uint32_t>(descriptorSetsGroup.size()),
				descriptorSetsGroup.data(), 0, nullptr);

			// Execute pipeline
			vkCmdDrawIndexed(commandBuffers[currentImage],
				static_cast<uint32_t>(model.getMesh(k)->getIndexCount()), 1, 0, 0, 0);
		}
	}
	...
```

Your code should now draw. Nevertheless, the view is not optimal. Change it in `init` (view matrix) so you can see your model. For me it will be:

```
uboViewProjection.view = glm::lookAt(glm::vec3(10.0f, 10.0f, 20.0f),
	glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
```

You can remove the quad's code. In order to use a default texture when the model texture cannot load, you can create a texture in `init` before loading the model:

```
		// Default texture
		createTexture("cat.jpg");

		// Load model
		createMeshModel("models/Futuristic combat jet.obj");
```

We also need to change the `updateModel` function:

```
void VulkanRenderer::updateModel(int modelId, glm::mat4 modelP)
{
	if (modelId >= meshModels.size()) return;

	meshModels[modelId].setModel(modelP);
}
```

#### Loading in main

We can also set `createMeshModel` to public and use it in the main:

`Main.cpp`
```
int main()
{
	initWindow();
	if(vulkanRenderer.init(window) == EXIT_FAILURE) return EXIT_FAILURE;

	float angle = 0.0f;
	float deltaTime = 0.0f;
	float lastTime = 0.0f;

	// Load model
	vulkanRenderer.createMeshModel("models/Futuristic combat jet.obj");

	while (!glfwWindowShouldClose(window))
	{
		glfwPollEvents();

		float now = glfwGetTime();
		deltaTime = now - lastTime;
		lastTime = now;

		angle += 10.0 * deltaTime;
		if (angle > 360.0f) { angle -= 360.0f; }

		glm::mat4 rotationModelMatrix(1.0f);
		rotationModelMatrix = glm::translate(rotationModelMatrix, glm::vec3(-0.0f, 0.0f, -1.0f));
		rotationModelMatrix = glm::rotate(rotationModelMatrix, glm::radians(angle), glm::vec3(0.0f, 1.0f, 0.0f));
		vulkanRenderer.updateModel(0, rotationModelMatrix);

		vulkanRenderer.draw();
	}

	clean();
	return 0;
}
```

The only problem is that the 0 in `vulkanRenderer.updateModel(0, rotationModelMatrix);` is hard coded. We need an id from the list of models. Let's modify `createMeshModel` to return such an id.

```
int VulkanRenderer::createMeshModel(string filename)
{
	...
	return meshModels.size() - 1;
}
```

Now we can use it in main:

`Main.cpp`
```
	// Load model
	int modelId = vulkanRenderer.createMeshModel("models/Futuristic combat jet.obj");

	while (!glfwWindowShouldClose(window))
	{
		...
		vulkanRenderer.updateModel(modelId, rotationModelMatrix);
		...
	}
	...
```

## Conclusion

We now have seen the basics of a vulkan renderer. This code is not at all ready for production. It was meant more as a demonstration of the various usual vulkan concepts. If you want to implement a real-time engine, use this knowledge with https://vkguide.dev, especially if you are interested in engine programming.

Nevertheless, there is a concept specific to Vulkan we still have to develop. **Subpasses** will be the subject of the next lesson.